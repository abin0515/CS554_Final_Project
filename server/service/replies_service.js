import { ObjectId } from 'mongodb';
// import { posts, replys } from '../config/mongoCollections.js'; // No longer needed directly
// import * as postService from './post_service.js'; // Likely no longer needed if not using other post services

import {
    createReplyInDB,
    getReplyByIdFromDB,
   
    getRepliesByPostIdFromDB,
    getSubRepliesByAnswerIdFromDB,
    incrementReplyLikeTimes,
    decrementReplyLikeTimes,
    incrementReplyTimesInDB
} from '../data/replies.js';
import {
    getPostByIdFromDB,
    incrementPostReplyCountInDB,
    incrementPostTotalLikeNumInDB,
    decrementPostTotalLikeNumInDB
} from '../data/posts.js';
import { publishMessage } from '../config/rabbitmq.js';
const EXCHANGE_NAME = 'app_events';
const EXCHANGE_TYPE = 'direct';
const REPLIES_EVENT_POINTS_BINDING_KEY = 'replies.event.points';
/**
 * Creates a new reply for a post.
 * @param {string} postId - The ID of the post being replied to.
 * @param {string} userId - The ID of the user creating the reply.
 * @param {string} content - The content of the reply.
 * @param {string|null} targetUserId - The ID of the user being replied to (optional).
 * @param {string|null} targetReplyId - The ID of the reply being replied to (optional).
 * @param {boolean} anonymity - Whether the reply is anonymous.
 * @returns {object} The newly created reply document.
 */
const createReply = async (
    post_id,
    answer_id,
    user_id,
    content,
    target_user_id, // ID of the reply being replied to (optional)
    target_reply_id,  // ID of the user being replied to (optional)
    
    anonymity = false // Default to not anonymous
) => {
   
    // Check if the post exists using the data function
    const postExists = await getPostByIdFromDB(post_id);
    if (!postExists) {
        throw new Error('Post not found.'); // Or throw a specific error type
    }

   
    
    // TODO: Add check for targetUserId existence if necessary (requires a user data function)
    
    // Prepare reply data for insertion (ObjectIds handled in data layer if needed)
    const newReplyData = {
        // _id will be generated by MongoDB or the data function
        post_id: post_id, // Keep as ObjectId for DB
        answer_id: answer_id,
        user_id: user_id,
        content: content,
        target_user_id: target_user_id ,
        target_reply_id: target_reply_id,
        reply_times: 0,
        liked_times: 0,
        anonymity: anonymity,
        create_time: new Date(),
        update_time: new Date()
    };

    // Create reply using the data function
    const addedReply = await createReplyInDB(newReplyData);
    if (!addedReply) {
        // createReplyInDB throws on failure, but good practice to check
        throw new Error('Could not add reply via data function.'); 
    }

    // --- Update Counts (Post-Reply Creation) ---
    try {
        // Increment post reply count
        await incrementPostReplyCountInDB(post_id);
        // send message to points server
        const messagePayload2PointsServer = {
            userId: user_id,
            type: 2, // type 2 for reply event
            point: 2,
            timestamp: new Date().toISOString()
        };
        const sendToPointsServerSuccess = await publishMessage(EXCHANGE_NAME, REPLIES_EVENT_POINTS_BINDING_KEY, messagePayload2PointsServer, EXCHANGE_TYPE);
        if (!sendToPointsServerSuccess) {
            console.warn(`Failed to publish reply event for post ${post_id} to RabbitMQ.`);
        }
    } catch (updateError) {
        // Log this error, but the reply creation itself was successful
        // Consider a more robust error handling/logging strategy
        console.error(`Failed to update reply counts for post ${post_id} :`, updateError);
    }
    // --- End Update Counts ---

    return addedReply; // Return the reply object (with string IDs from getReplyByIdFromDB)
};

/**
 * Gets a single reply by its ID.
 * @param {string} replyId - The ID of the reply.
 * @returns {object} The reply document.
 */
export async function getReplyById(replyId) {
    replyId = validation.checkId(replyId, 'Reply ID'); // Validate ID at service layer
    const reply = await getReplyByIdFromDB(replyId); // Call data layer function
    if (!reply) {
        throw new Error('Reply not found.'); // Service layer handles 'not found'
    }
    return reply;
}

/**
 * Gets all replies associated with a specific post ID.
 * @param {string} postId - The ID of the post.
 * @returns {Promise<Array<object>>} An array of reply objects.
 */
export async function getRepliesByPostId(postId) {
    // Service level validation
    // Optional: Could add a check here to ensure the post itself exists using getPostByIdFromDB
    // const postExists = await getPostByIdFromDB(postId);
    // if (!postExists) {
    //     throw new Error('Post not found when fetching replies.');
    // }
    const replies = await getRepliesByPostIdFromDB(postId);
    return replies; // Return the array (could be empty)
}



/**
 * Gets sub-replies associated with a specific top-level answer ID within a post.
 * @param {string} postId - The ID of the post.
 * @param {string} answerId - The ID of the top-level answer reply.
 * @returns {Promise<Array<object>>} An array of sub-reply objects.
 */
export async function getSubRepliesByAnswerId(postId, answerId) {
    

    const subReplies = await getSubRepliesByAnswerIdFromDB(postId, answerId);
    return subReplies; // Return the array (could be empty)
}

// Add other reply-related service functions here (e.g., deleteReply, etc.) 
// These should also call corresponding data layer functions

export async function handleLikesTask(bizId, userId, liked) { // liked is likely string "true" or "false"
    const reply = await getReplyByIdFromDB(bizId);
    if (!reply) {
        console.error(`(handleLikesTask) Reply not found for bizId: ${bizId}`);
        return; // Cannot proceed without reply to get post_id
    }

    // Explicitly check the *string* value received from the message queue
    if (liked === 'false') { 
        // Decrement logic
        
        await decrementReplyLikeTimes(bizId); 
        await decrementPostTotalLikeNumInDB(reply.post_id);
    } else { 
        // Increment logic (Handles liked === 'true' or potentially unexpected values)
        
        await incrementReplyLikeTimes(bizId);
        await incrementPostTotalLikeNumInDB(reply.post_id);
    }
}

export async function incrementReplyTimes(answerId) {
    try {
        if(answerId !== null) {
            await incrementReplyTimesInDB(answerId);
        }
    } catch (error) {
        console.error(`(incrementReplyTimes) Error incrementing reply times for answerId: ${answerId}`, error);
    }
}

export default {
    createReply,
    getReplyById,
    getRepliesByPostId,
    incrementReplyTimes,
    
    getSubRepliesByAnswerId,
    handleLikesTask
}; 