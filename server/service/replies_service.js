import { ObjectId } from 'mongodb';
// import { posts, replys } from '../config/mongoCollections.js'; // No longer needed directly
// import * as postService from './post_service.js'; // Likely no longer needed if not using other post services

import {
    createReplyInDB,
    getReplyByIdFromDB,
    incrementReplyCountInDB,
    getRepliesByPostIdFromDB,
    getSubRepliesByAnswerIdFromDB
} from '../data/replies.js';
import {
    getPostByIdFromDB,
    incrementPostReplyCountInDB
} from '../data/posts.js';

/**
 * Creates a new reply for a post.
 * @param {string} postId - The ID of the post being replied to.
 * @param {string} userId - The ID of the user creating the reply.
 * @param {string} content - The content of the reply.
 * @param {string|null} targetUserId - The ID of the user being replied to (optional).
 * @param {string|null} targetReplyId - The ID of the reply being replied to (optional).
 * @param {boolean} anonymity - Whether the reply is anonymous.
 * @returns {object} The newly created reply document.
 */
const createReply = async (
    post_id,
    answer_id,
    user_id,
    content,
    target_user_id, // ID of the reply being replied to (optional)
    target_reply_id,  // ID of the user being replied to (optional)
    
    anonymity = false // Default to not anonymous
) => {
   
    // Check if the post exists using the data function
    const postExists = await getPostByIdFromDB(post_id);
    if (!postExists) {
        throw new Error('Post not found.'); // Or throw a specific error type
    }

   
    
    // TODO: Add check for targetUserId existence if necessary (requires a user data function)
    
    // Prepare reply data for insertion (ObjectIds handled in data layer if needed)
    const newReplyData = {
        // _id will be generated by MongoDB or the data function
        post_id: post_id, // Keep as ObjectId for DB
        answer_id: answer_id,
        user_id: user_id,
        content: content,
        target_user_id: target_user_id ,
        target_reply_id: target_reply_id,
        reply_times: 0,
        liked_times: 0,
        anonymity: anonymity,
        create_time: new Date(),
        update_time: new Date()
    };

    // Create reply using the data function
    const addedReply = await createReplyInDB(newReplyData);
    if (!addedReply) {
        // createReplyInDB throws on failure, but good practice to check
        throw new Error('Could not add reply via data function.'); 
    }

    // --- Update Counts (Post-Reply Creation) ---
    try {
        // Increment post reply count
        await incrementPostReplyCountInDB(post_id);

    
    } catch (updateError) {
        // Log this error, but the reply creation itself was successful
        // Consider a more robust error handling/logging strategy
        console.error(`Failed to update reply counts for post ${post_id} :`, updateError);
    }
    // --- End Update Counts ---

    return addedReply; // Return the reply object (with string IDs from getReplyByIdFromDB)
};

/**
 * Gets a single reply by its ID.
 * @param {string} replyId - The ID of the reply.
 * @returns {object} The reply document.
 */
export async function getReplyById(replyId) {
    replyId = validation.checkId(replyId, 'Reply ID'); // Validate ID at service layer
    const reply = await getReplyByIdFromDB(replyId); // Call data layer function
    if (!reply) {
        throw new Error('Reply not found.'); // Service layer handles 'not found'
    }
    return reply;
}

/**
 * Gets all replies associated with a specific post ID.
 * @param {string} postId - The ID of the post.
 * @returns {Promise<Array<object>>} An array of reply objects.
 */
export async function getRepliesByPostId(postId) {
    // Service level validation
    // Optional: Could add a check here to ensure the post itself exists using getPostByIdFromDB
    // const postExists = await getPostByIdFromDB(postId);
    // if (!postExists) {
    //     throw new Error('Post not found when fetching replies.');
    // }
    const replies = await getRepliesByPostIdFromDB(postId);
    return replies; // Return the array (could be empty)
}

/**
 * Increments the reply_times count for a specific reply.
 * @param {string} replyId - The ID of the reply to update.
 * @returns {Promise<boolean>} True if the update was acknowledged and matched a document.
 * @throws Will throw an error if the replyId is invalid or the update fails.
 */
export async function incrementReplyTimes(replyId) {
    // replyId = validation.checkId(replyId, 'Reply ID for incrementing times'); // Service level validation
    
    const success = await incrementReplyCountInDB(replyId);
    
    if (!success) {
        // incrementReplyCountInDB returns false if matchedCount was 0
        // We throw an error here because the caller expects the reply to exist.
        throw new Error(`Failed to increment reply times: Reply with ID ${replyId} not found or update failed.`);
    }
    return true; // Indicate success
}

/**
 * Gets sub-replies associated with a specific top-level answer ID within a post.
 * @param {string} postId - The ID of the post.
 * @param {string} answerId - The ID of the top-level answer reply.
 * @returns {Promise<Array<object>>} An array of sub-reply objects.
 */
export async function getSubRepliesByAnswerId(postId, answerId) {
    // Service level validation
    // postId = validation.checkId(postId, 'Post ID for fetching sub-replies');
    // answerId = validation.checkId(answerId, 'Answer ID for fetching sub-replies');
    
    // Optional: Check if post and answer exist before fetching sub-replies
    // await getPostByIdFromDB(postId); 
    // await getReplyByIdFromDB(answerId);

    const subReplies = await getSubRepliesByAnswerIdFromDB(postId, answerId);
    return subReplies; // Return the array (could be empty)
}

// Add other reply-related service functions here (e.g., deleteReply, etc.) 
// These should also call corresponding data layer functions

export default {
    createReply,
    getReplyById,
    getRepliesByPostId,
    incrementReplyTimes,
    getSubRepliesByAnswerId
}; 